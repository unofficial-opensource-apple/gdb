***************
*** 1692,1788 ****
    dont_repeat ();
  
    if (args == NULL)
-     error ("add-symbol-file takes a file name and an address");
- 
-   /* Make a copy of the string that we can safely write into. */
-   args = xstrdup (args);
  
    /* Ensure section_addrs is initialized */
    memset (&section_addrs, 0, sizeof (section_addrs));
  
-   while (*args != '\000')
      {
-       /* Any leading spaces? */
-       while (isspace (*args))
- 	args++;
- 
-       /* Point arg to the beginning of the argument. */
-       arg = args;
- 
-       /* Move args pointer over the argument. */
-       while ((*args != '\000') && !isspace (*args))
- 	args++;
- 
-       /* If there are more arguments, terminate arg and
-          proceed past it. */
-       if (*args != '\000')
- 	*args++ = '\000';
- 
-       /* Now process the argument. */
-       if (argcnt == 0)
- 	{
- 	  /* The first argument is the file name. */
- 	  filename = tilde_expand (arg);
- 	  make_cleanup (xfree, filename);
  	}
        else
- 	if (argcnt == 1)
- 	  {
- 	    /* The second argument is always the text address at which
-                to load the program. */
- 	    sect_opts[section_index].name = ".text";
- 	    sect_opts[section_index].value = arg;
- 	    section_index++;		  
- 	  }
- 	else
- 	  {
- 	    /* It's an option (starting with '-') or it's an argument
- 	       to an option */
- 
- 	    if (*arg == '-')
- 	      {
- 		if (strcmp (arg, "-mapped") == 0)
- 		  flags |= OBJF_MAPPED;
- 		else 
- 		  if (strcmp (arg, "-readnow") == 0)
- 		    flags |= OBJF_READNOW;
- 		  else 
- 		    if (strcmp (arg, "-s") == 0)
- 		      {
- 			if (section_index >= SECT_OFF_MAX)
- 			  error ("Too many sections specified.");
- 			expecting_sec_name = 1;
- 			expecting_sec_addr = 1;
- 		      }
- 	      }
- 	    else
- 	      {
- 		if (expecting_sec_name)
- 		  {
- 		    sect_opts[section_index].name = arg;
- 		    expecting_sec_name = 0;
- 		  }
- 		else
- 		  if (expecting_sec_addr)
- 		    {
- 		      sect_opts[section_index].value = arg;
- 		      expecting_sec_addr = 0;
- 		      section_index++;		  
- 		    }
- 		  else
- 		    error ("USAGE: add-symbol-file <filename> <textaddress> [-mapped] [-readnow] [-s <secname> <addr>]*");
- 	      }
- 	  }
-       argcnt++;
      }
  
    /* Print the prompt for the query below. And save the arguments into
       a sect_addr_info structure to be passed around to other
       functions.  We have to split this up into separate print
       statements because local_hex_string returns a local static
       string. */
   
-   printf_filtered ("add symbol table from file \"%s\" at\n", filename);
    for (i = 0; i < section_index; i++)
      {
        CORE_ADDR addr;
--- 1882,1984 ----
    dont_repeat ();
  
    if (args == NULL)
+     error (usage_string, "argument required");
  
    /* Ensure section_addrs is initialized */
    memset (&section_addrs, 0, sizeof (section_addrs));
  
+   argv = buildargv (args);
+   if (argv == NULL)
+     nomem (0);
+   make_cleanup_freeargv (argv);
+ 	  
+   argcnt = 0;
+   for (;;)
      {
+       arg = argv[argcnt++];
+       if (arg == NULL)
+ 	break;
+ 
+       /* It's an option (starting with '-'), an argument
+ 	 to an option, or the filename. */
+ 
+       if (*arg == '-')
+ 	{
+ 	  if (strcmp (arg, "-mapaddr") == 0)
+ 	    {
+ 	      char *atmp = argv[argcnt++];
+ 	      if (atmp == NULL)
+ 		error (usage_string, "must specify address to -mapaddr");
+ 	      mapaddr = parse_and_eval_address (atmp);
+ 	    }
+ 	  if (strcmp (arg, "-prefix") == 0)
+ 	    {
+ 	      char *atmp = argv[argcnt++];
+ 	      if (atmp == NULL)
+ 		error (usage_string, "must specify address to -prefix");
+ 	      prefix = xstrdup (atmp);
+ 	    }
+ 	  else if (strcmp (arg, "-mapped") == 0)
+ 	    flags |= OBJF_MAPPED;
+ 	  else if (strcmp (arg, "-readnow") == 0)
+ 	    flags |= OBJF_READNOW;
+ 	  else if (strcmp (arg, "-s") == 0)
+ 	    {
+ 	      char *atmp = argv[argcnt++];
+ 	      if (atmp == NULL)
+ 		error (usage_string, "must specify section name to -s");
+ 
+ 	      char *atmp2 = argv[argcnt++];
+ 	      if (atmp2 == NULL)
+ 		error (usage_string, "must specify section address to -s");
+ 
+ 	      if (section_index >= SECT_OFF_MAX)
+ 		error (usage_string, "too many sections specified.");
+ 
+ 	      sect_opts[section_index].name = atmp;
+ 	      sect_opts[section_index].value = atmp2;
+ 	      section_index++;		  
+ 	    }
  	}
        else
+ 	{
+ 	  if (filename == NULL)
+ 	    {
+ 	      filename = tilde_expand (arg);
+ 	      make_cleanup (xfree, filename);
+ 	    }
+ 	  else if (address == NULL)
+ 	    {
+ 	      address = arg;
+ 	    }
+ 	  else
+ 	    {
+ 	      error (usage_string, "too many arguments");
+ 	    }
+ 	}
      }
  
+   if (address != NULL)
+     error (usage_string, "address specified without -s option");
+ 
+   if (filename == NULL)
+     error ("usage: must specify exactly one filename");
+ 
    /* Print the prompt for the query below. And save the arguments into
       a sect_addr_info structure to be passed around to other
       functions.  We have to split this up into separate print
       statements because local_hex_string returns a local static
       string. */
   
+   /* APPLE LOCAL:  Don't print ``at\n'' (which should be followed by
+      a list of sections and addresses) if there are no sections and
+      addresses supplied (i.e. "add-symbol-file a.out")  */
+   printf_filtered ("add symbol table from file \"%s\"", filename);
+   if (section_index > 0)
+     printf_filtered (" at\n");
+   else 
+     printf_filtered ("? ");
+ 
    for (i = 0; i < section_index; i++)
      {
        CORE_ADDR addr;
***************
*** 1848,1874 ****
       This routine should then walk down each partial symbol table
       and see if the symbol table that it originates from has been changed */
  
-   for (objfile = object_files; objfile; objfile = objfile->next)
      {
        if (objfile->obfd)
  	{
- #ifdef IBM6000_TARGET
- 	  /* If this object is from a shared library, then you should
- 	     stat on the library name, not member name. */
- 
- 	  if (objfile->obfd->my_archive)
- 	    res = stat (objfile->obfd->my_archive->filename, &new_statbuf);
- 	  else
- #endif
- 	    res = stat (objfile->name, &new_statbuf);
- 	  if (res != 0)
- 	    {
- 	      /* FIXME, should use print_sys_errmsg but it's not filtered. */
- 	      printf_filtered ("`%s' has disappeared; keeping its symbols.\n",
- 			       objfile->name);
- 	      continue;
- 	    }
- 	  new_modtime = new_statbuf.st_mtime;
  	  if (new_modtime != objfile->mtime)
  	    {
  	      struct cleanup *old_cleanups;
--- 2051,2071 ----
       This routine should then walk down each partial symbol table
       and see if the symbol table that it originates from has been changed */
  
+   ALL_OBJFILES (objfile)
      {
        if (objfile->obfd)
  	{
+ 	  {
+ 	    /* Stat the file by path, when one is available, to detect
+ 	       the case where the file has been replaced, but BFD
+ 	       still has a file descriptor open to the old version. */
+ 
+ 	    struct stat buf;
+ 	    if (stat (objfile->obfd->filename, &buf) != 0)
+ 	      new_modtime = bfd_get_mtime (objfile->obfd);
+ 	    else
+ 	      new_modtime = buf.st_mtime;
+ 	  }
  	  if (new_modtime != objfile->mtime)
  	    {
  	      struct cleanup *old_cleanups;
